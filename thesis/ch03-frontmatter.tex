%% ----------------------------------------------------------------------
%% START OF FILE
%% ----------------------------------------------------------------------
%% 
%% Filename: ch03-frontmatter.tex
%% Author: Fred Qi
%% Created: 2012-12-26 09:12:47(+0800)
%% 
%% ----------------------------------------------------------------------
%%% CHANGE LOG
%% ----------------------------------------------------------------------
%% Last-Updated: 2013-03-12 08:16:15(+0800) [by Fred Qi]
%%     Update #: 19
%% ----------------------------------------------------------------------
\chapter{CBDRF算法的提出}
\label{chap:outline}

由于在集群调度时，尤其是在集群管理的第一层调度的时候，往往只考虑了资源的拆分，而对任务间的关联关系对虚拟机的调度尤其是虚拟机的摆放位置的要求往往很高，
而传统的资源调度系统在这方面往往考虑有所不足，本章以此为切入，详细的介绍了CBDRF调度系统的动机和与此相关的背景知识。

\section{CBDRF调度系统的提出}

云计算作为整合互联网资源的计算模式，在这种模式下，用户可以随时随地的所需的获取丰富多样的计算，资源服务。在云计算平台中，用户可以按照自己
的实际需求按照实际使用的使用需求按需付费。从而大大减少了平台的维护代价。虚拟化技术作为云计算服务实现的重要手段，大大的提高了资源的利用情况
和资源的利用率。简化了资源的管理和维护成本。云计算平台的调度器，负责维护封装虚拟资源的核心模块，一直是学术界和工业界研究的重点，资源调度结果的
情况对云计算平台的计算性能和资源利用情况会产生重大的影响。不论是全局调度器还是作为两级调度调度器的中央调度器，资源分配的合理性公平性也是云计算平台的重点问题。
目前主要有以下几种算法解决云计算平台的虚拟机资源调度策略的方法：
 \begin{enumerate}
\item 从平台的负载角度出发，当个任务或是应用发出虚拟机资源的请求时，平台检查所有物理机上的剩余资源，
将满足物理机请求的资源的物理机过滤出来，尽量使得各个物理机上的负载均衡。
\item 从平台的资源的利用的效率出发，当任务或是应用发出虚拟机资源请求时，检查所有物理家上的剩余资源，
采用最少的物理机来满足任务或是应用对资源的请求，使得任务平台整体的能够有较少的使用物理资源，减少不必要的资源浪费。
\item 基于公平性的调度算法，以DRF算法为例的公平调度算法，主要考虑各个资源分配直接的均衡和合理，
可以使得任务之间对资源的请求和分配达到经济学上的帕累托最优。
\end{enumerate}

而在目前的任务处理中，一般对虚拟机或是计算资源的请求
上述种方法在解决云计算中虚拟机资源调度问题的方法有各自的局限性：
\begin{enumerate}
\item 负载均衡算法为了保证各个物理机上的虚拟机负载尽可能一致，会导致虚拟机的分配方案相对比较松散，导致有大量交互或是大量网络通讯的任务或应用会或得比较糟糕的网络状况，导致服务质量的下降或是任务执行的时延增加。
\item 平台利用率的算法，尽量采用少量的物理机满足应用的虚拟机资源请求会或得比较好的资源利用情况，但是这种算法是一个典型的NP问题，求解这个问题往往会造成更高的调度代价，因此在实际的云计算平台中很少采用。
\item DRF算法本身在资源的利用情况会造成比较多的碎片情况，导致可分配，可调度的次数有所不足，另外由于忽略了本身物理机的位置的关系，会造成了物理机资源和任务的实际运行的网络情况不匹配的。
\end{enumerate}

综上，上述三种算法均在任务的通信请求和任务执行存在关联关系的问题上的考虑均有所不足，并且各自对资源的请求分配的情况均存在自己本身不足的因素。所以对大量通信的任务请求的调度结果往往不能取得较好的性能优势。

\subsection{任务的关联性}
在大规模的协同计算平台下，任务之间往往是存在关联性的。这种关联性主要有以下的三种关联，无关联的独立任务，DAG关联任务，和通信关联任务。

无关联的任务之间往往没有任何耦合关系，在计算任务时，这种任务往往是并行优化的重点作业，由于不存在任何的关联。
这些任务对资源的请求往往比较独立，没有任何的关联性，所以在资源的申请时往往不考虑通信和数据局部性的关系。

DAG关联任务是比较常见的协同作业之一，这种作业往往是把前一作业的输出作为下一作业的输入进行。这两个作业
耦合度比较浅，仅仅上一个任务结束和下一个相关的任务开始时有耦合关系。但是由于是一种特殊的类似拓扑关系
的耦合，导致如果上一作业没有进行完毕那么下一作业则不能开始执行，另外，由于存在一定的数据耦合，所以在大规模
集群计算的背景下，对数据的局部性要求是比较高的，如果花费大量的时间在中间输入和输出的传输和一致性同步上，将会
大幅的降低集群的计算性能，因此这种类型的作业极大的考虑数据的局部性。

通信关联任务是最为常见的协同作业。这种作业以MPI为例，分布式的进程互相之间首先需要大量的交换中间数据。交换的频繁
程度以用户的程序规定，一般会比较密集。并且这种作业的计算时间往往会比较长，以科研的高性能仿真实验为主。耗费大量的
CPU，内存，网络和硬盘数据。任务之间因为程序的不同，导致中间通信的代价往往不同。但是一旦存在互相之间的通信关系，那么
在DAG作业的基础之上，除了考虑数据的局部性之外，对于网络的拓扑情况也必须加以考虑。以MPI为例，同一局域网下的MPI的执行
效率至少是异地跨网段MPI执行效率的7倍，最差的时候多达35倍。还有一种关联任务虽然是有向的单向边形式存在，但是其互相依赖，
使得在途中构成了一个回路，这几个任务正是图论中对强联通分量的定义。所以这也是一种通信关联任务。
\begin{figure}[htbp]
\centering\includegraphics[scale=1]{CBTask-crop}
\caption{通信关联任务的两种类型}\label{fig:CBTask}
\end{figure}

因此，在进行资源的调度的过程中，必须对资源的局部性和网络位置来考虑资源的分配，以往的资源分配往往仅仅将资源分配
抽象成一个切蛋糕或是划分资源池的过程远远不能满足框架的计算特性。好的资源切分可以使得框架的调度结果的性能有很大的
提升。

\subsection{系统的负载均衡}
云计算平台的一个重要的指标是计算的性能，以虚拟化为主的云计算平台上物理机的负载情况是影响虚拟机的计算性能的重要因素。
实践证明，当物理机上的建立的虚拟机的数量越多，物理机的负载越大，该宿主机上的虚拟机的效率下降越多。

当物理机上建立的虚拟机较少，内存的负载较低时，在物理机上建立虚拟机个数比较少的情况下，虚拟机的性能基本保持不错，和相同配置的物理机的性能几乎相同。
而在此基础之上，如果继续加大虚拟机的个数，可以发现虚拟机的性能开始下降，但下降的趋势和虚拟机的个数基本成成正比关系。
但此时单个虚拟机性能的下降的损失可以被增加的虚拟机个数所弥补。当实际的负载进一步加大，虚拟机的性能此时急剧下降，增
加的虚拟机的个数完全不能弥补单个虚拟机性能的下降所造成的对整个集群啊性能的影响。

从此可以发现，单个物理机的负载必须在一个合适的范围内。在整个集群中，如果某个调度的策略不当，使得某个物理机的负载过高。
会使得该物理机上的运行的虚拟机的效率大大降低，从而使得在该虚拟机上实际运行的任务的效率大大降低，进而会影响与之有通信关联
或是DAG关联任务的执行，使得整个系统的执行效率降低。所以从资源调度的角度出发考虑，应当避免某个虚拟机的负载过高的情况出现。

针对系统的负载均衡，Openstack的scheduler采用了filter－scheduler的策略，这个调度器的调度即就是采用基于负载均衡的角度设计的调度器
其调度的过程主要分一下两个决策过程。
\begin{itemize}
\item filter：这个过程是过滤的过程。按照用户的需求，过滤掉不符合调度策略的物理机。filter的策略配置有基于内存的过滤器ram\_filter，
基于vcpu的core\_filter等，作为云计算的调度器的调度器设计者或是平台维护者，也可以添加自己的filter的实现。
在调度的过程中，根据调度器开发者或是平台维护者的设置来选取不同的filter，可以选择其中的一个或者多着过滤器。多个
过滤器过滤的过程中对每个过滤器都进行一次过滤从而过滤出符合规则的调度器。
\item weight：当过滤过程结束之后将进入weight过程，这个weight的过程的实质是按照集权本身的负载情况进行排序，每次选取负载最小的
主机作为最终的调度结果。其中weigh的函数仍然可以由调度器设计者或是平台维护者自行定义，目前的Openstack的调度器是采用的基于内存
的负载情况考虑，选择内存负载压力最小的主机作为最终的调度结果。
\end{itemize}

其他的基于负载均衡的调度策路还有，round-robin调度策路，best-fit策略，first-fit策略，这些策略都是基于当前云计算平台
的负载状态的所做出的调度策路。本质上使得每个物理机上的负载尽量相同，使得每台物理机的负载差异较小，不会出现单个物理机
负载过大，降低整体云计算平台整体性能下滑。

\subsection{主资源公平策略}
主资源公平（Dominant Resource Fairness）策略是UCBerkly提出的一种基于多资源的公平的资源分配，也是作为Apache Mesos的中央调度器所采用的
公平策略，其本质是最大最小公平的一个实现。在先前的云计算平台中大多采用的是基于单资源的公平分配，而DRF算法将这这种公平扩展向了多资源公平。

对于每个用户，DRF算法首先会计算分配给每个用户各个资源维度的分享量。而某个维度上分享量的中最大的值称为该需求的主分享量（domainit share）。
此时这个主分量的资源被叫做这个用户的主资源（domainint Resource）。对于不同类型的计算任务，其主资源的分配往往是不尽相同的，对于计算任务而言，
其主资源时CPU，而对缓存任务而言其主资源时内存而某些MPI计算任务其带宽则是其主资源，DRF算法的主旨是使得各个主分享量尽量相同。其算法的伪代码
算法5所示：
\begin{algorithm} 
\caption {DRF算法} 
\begin{codebox}
\Procname{$\proc{DRF allocation}()$}
\li	$R \leftarrow \left({r}_{1},...{r}_{m} \right)$ \RComment 所有的资源，共M种
\li	$C \leftarrow \left({c}_{1},...{c}_{m}\right)$ \RComment 已消费的资源，初始均为0
\li	${S}_{i} (1 \leq i \leq n)$				\RComment n个待分配的主分享向量，初始均为0
\li	${U}_{i} \leftarrow {{u}_{i,1},...{u}_{i,m}}(1 \leq i \leq n)$	\RComment 分配给i的资源数，初始为0
\li	$i \leftarrow {argmin}_{1 \leq i \leq n} {{S}_{i}}$ \RComment 选取主分享向量最小的
\li	${D}_{i} \leftarrow {{d}_{i},...{d}_{m}}$ \RComment 待分配的需求向量
\li	\If $C + {D}_{i} \leq R$
\li	\Then 
		$C \leftarrow C + D_{i}$                  
\li            	${U}_{i} \leftarrow {U}_{i} + {D}_{i}$ 
\li		${S}_{i} \leftarrow \max \limits_{1 \leq j \leq m} {{{u}_{i,j}}/{r}_{j}}$ \RComment 更新主分享向量
\li	\Else
\li		\Return
	\End
\end{codebox}
\end{algorithm} 

例如对于一个拥有<9CPU, 18GB>的系统，如果此时有两个任务A，B分别要求<1CPU，4GB>和<3CPU,1GB>内存的任务，按照，此时A任务的主资源为内存，B
任务的主资源为CPU，如果系统的资源要求尽可能全部分配，按照主资源公平算法5所述，进行5次调用，那么A任务将会分得<3CPU，12GB>内存，而B任务最终会被分配<6CPU，2GB>。
其分配的过程如表3.1所示
\begin{table}[htp]
\begin{center}
\caption{DRF的分配示例}
\begin{tabular}{|c|c|c|c|c|}
\hline
分配过程 & A的分配向量&A的主分享量&B的分配向量&B的主分享量\\
\hline
B & <0,0> & 0 & <3,1> & 1/3\\
\hline
A & <1,4> & 2/9 & <3,1> & 1/3\\
\hline
A & <2,8> & 4/9 & <3,1> &1/3\\
\hline
B & <2,8> & 4/9 & <6,2> & 2/3\\
\hline
A & <4,12> & 2/3 & <6,2> & 2/3\\
\hline
\end{tabular}
\end{center}
\label{tab:drfexample}
\end{table}

采用DRF算法的分配的各个向量之间的公平和负载时比较均衡的，DRF算法是很好的实现的资源负载的公平性
分配，当时DRF算法的一个重要问题如其算法的提出者所说，其仍将资源抽象成一个资源池的模型，没有考虑
资源分配的具体位置。对不同类型的框架任务来说，往往资源分配的主机位置，通信网络状态时影响计算性能
的重要因素。这一是限制DRF资源分配算法进一步提升的系统的空间。

\section{图的联通性算法}
图的连通性问题，作为图论中解决关联性问题的核心利器，在解决图的关系中有着重要的作用。由于任务直接的关系
是一种特殊的图的关联关系，在解决任务的关联性问题中起着重要的作用。本节中，将详细介绍图论算法在解决图的
连通性问题上的常见解决方法。从而使得CBDRF算法在任务解析中做到更加精确合理。
\subsection{强联通分量}
在一个图中，如果其中的边如果是有方向的，则这样的图被称为是一个有向图。而在一个有向图中，存在一对顶点u，v
如果存在从u到v和v到u的两条路径，则这两点是强联通的。进一步的讲，如果图中的任意两个点均是强联通的，这样图
就是一个强联通图。而在非强联图图中，一定存在一个子图，这个字图是一个强联通图，这样子图中的极大强联通字图，
被称为是图中的一个强联通分量。

如图\ref{fig:SCC}所示，因为顶点1，2，3两两可达，因此图中的节点（1，2，3）构成一个强连通分量。
同理可得，（4，5，6）这三个点也构成了该图的一个强连通分量。
\begin{figure}[htbp]
\centering\includegraphics[scale=0.5]{SCC-crop}
\caption{强联通分量关系图}\label{fig:SCC}
\end{figure}
显然可以采用暴力的算法求解强联通分量，采用双向遍历整个图，然后对每个得到可以的分量取交集可以得到图的所有的强联通分量。
但这种方法的负杂度是$O({N}^{2} + M)$（其中$N$是图的顶点的个数，$M$是图中边的个数）。这种算法由于时间复杂度较高，在实际的使用
中往往采用效率较高的Tarjan算法和Kosaraju算法。Tarjan算法\cite{ref18}和Kosaraju算法这两个算法均是以图的深度优先搜索算法为基础，在深度优先
遍历搜素图的基础上进行了优化，复杂度只有$O(N + M)$。其中Kosaraju算法要对图进行两次深度优先搜索，而
Tarjan算法只进行一遍深度优先搜索索。结合实际的计算，一般来说Tarjan算法比进行两遍深度优先搜索Kosaraju算法有30\%的性能提升。

与其他图论的算法类似，Tarjan算法的输入仍然是一个有向图，其输出为该图的各个联通分量。
在计算开始时，首先定义图中节点的u的深度搜索时间戳$DFN(u)$，表示在搜索过程中第一次访问节点u的顺序编号。
另外，针对每个节点$u$，还应当计算一个反向时间戳$Low(u)$，这个表示从$u$出发通过图中的有向边，可以访问的最早的访问顺序。
显然深度搜索的过程中，对于节点$u$来说，$Low(u)$的值一定是不大于$DFN(u)$的，如果这两个值相等，则说明
以节点u为根节点为搜索子树上的其他节点无法到达比$u$更早的节点，子树中的节点能访问的均在已$u$为根的搜索子树中。
因此，此时以$u$为根的搜索子树上的节点必然是在同一强连通分量中。因此可以得到这么一个结论，如果
以u为根的搜索子树上的节点在同一个强联通分量的充分必要条件是$Low(u)$必须等于$DFN(u)$。
从$Low(u)$的定义可以发现，$Low(u)$的计算情况是以下三种情况的最小值
$$Low(u)=\min
\begin{cases}
DFN(u) & \\
Low(v)& \text{(u,v)为树枝边，u为v的父节点}\\
DFN(v)& \text{(u,v)为指向栈中节点的后向边(非横叉边)}
\end{cases}$$

由此可得，Tarjan算法的基本流程如下：
\begin{enumerate}
\item	首先遍历图中的各个节点，如果该节点已经已经在先前的搜索中被访问，则不对该节点进行深度优先遍历，否则，对该节点进行遍历。
\item	在搜索的过程中首先将节点入栈，对其邻近节点进行进行搜索操作，更新$DFN(u)$和$Low(u)$值。
\item	如果出现$DFN(u)$和$Low(u)$相同的节点$u$，那么将包括$u$以上的节点全部出栈，这些节点属于同一个强联通分量。
\item 如果此次搜索完成后，节点仍有未被搜索的节点，那么以此节点继续进行搜索。
\end{enumerate}

下面给出了Tarjan算法在搜索过程中执行流程的伪代码：
\begin{algorithm} 
\caption {Tarjan Algorithm} 
\begin{codebox}
\Procname{$\proc{tarjan}(u)$}
\li	$Index \leftarrow time + 1$
\li	$DFN[u] \leftarrow time$
\li	$Low[u] \leftarrow time$
\li	$Stack.push(u)$
\li	\For $each (u, v)$ $in$ $E[u]$
\li		\Do  \If $\proc{visted}(v)$
\li			\Then
				$\proc{tarjan}(v)$                  
\li            			$Low[u] \leftarrow \min(Low[u], Low[v])$
\li        		 \ElseIf $\proc{inStack}(v)$ 
\li            			\Then $Low[u] \leftarrow \min(Low[u], DFN[v])$
			\End
		\End
\li	\If $DFN[u] \isequal Low[u]$
\li		\Then \While $u != v$
\li				\Do $v \leftarrow$ $\proc{Stack.pop}()$                  
\li            				$\proc{print}(v)$
				\End 
		\End
\end{codebox}
\end{algorithm} 

\subsection{拓扑排序}
在图论中，在一个有向图中，不存在任意一个顶点使得从该顶点出发在图中经过若干条边回来出发点的图被称作是有向无环图，简称DAG图。
\begin{figure}[htbp]
\centering\includegraphics[scale=0.5]{DAG-crop}
\caption{DAG图}\label{fig:DAG}
\end{figure}
在一个有向无环图中，一个节点可以经过两条或两条以上的路径而不形成环到达另外一个节点，
因此有向无环图并一定都是树的结构，如图\ref{fig:DAG}所示的有向无环图。但是任何一个有向树均可以构成一个有向无环图。

而拓扑排序则是将有向无环图的节点按照在图中出现的节点排序称为一个线性的序列。
这个序列使得图中的任意两个节点$u$，$v$，如果$u$和$v$之间存在一条从$u$指向$v$的有向边，那么拓扑
排序的序列中，$u$必然排在$v$之前。这样的一个序列被称作是满足拓扑排序次序的序列，也叫做拓扑序列。
从代数系统的角度上看，拓扑排序则是将一个偏序序列转化称为全序序列的操作的过程。
而这种序列的顺序对于同一个图来说往往不是唯一一个的最小序列。图中就可以有123456和213456这两个不同的拓扑序列。

拓扑排序的过程主要是以下两步，直到图中不存在入度为0的点则算法终止。
\begin{enumerate}
\item 首先，从图中选择一个入度为0的点，将其压入队列中。
\item 从对头选取一个节点，将与从该节点出发的有向边所指向的节点的入度减一。
\item 接下来，从队中弹出该节点，并遍历图中如果有新生成的入度为零的点，则加入队列之中。重复执行步骤2的过程。
\item 循环结束后，如果从队列中弹出的节点个数和图的节点的个数相同，则弹出的顺序就是一个拓扑序列。否则，该图就不是一个有向无环图。
\end{enumerate}

结合上述流程，可以得如下的算法伪代码。
\begin{algorithm} 
\caption {Topological Sort} 
\begin{codebox}
\Procname{$\proc{TopologicalSort}(G)$}
\li Queue.clear()
\li \For $each$ $vertex $ $u$ $in$ $G$
\li	\Do \If $\attribii{u}{indeg}  \isequal 0$
\li		\Then	$Q.push(u)$	
\li				$isVisited[u] \leftarrow True$
		\End
	\End
\li \While $\attribii{Queue}{\proc{size}()} > 0$
\li	\Do	$u \gets \attribii{Queue}{\proc{front}()}$
\li		$\attribii{Queue}{\proc{pop}()}$
\li		\For $each$ $(u,v)$ $in$ $ Edge[v]$
\li			\Do	$ \attribii{v}{indeg} \leftarrow  \attribii{v}{indeg} - 1$
\li			\If $\attribii{v}{indeg}  \isequal $0 and $isVisited[v] \isequal False$
\li				\Then	$Q.push(v)$
\li						$isVisited[v] \leftarrow True$
				\End
	\End
   \End
\end{codebox}
\end{algorithm} 
\subsection{并查集}
在计算机算法中，并查集\cite{ref19}是用于处理一些不相交集合的合并和查询的数据结构。并查集的实现有多种多样，常见的实现有基于线性数组，线性链表
的实现，还有比较高效的森林结构的实现。但这些实现中有以下2个必须存在的操作：
\begin{itemize}
\item Find：主要是确定该元素所在的集合，这个操作的一个重要的作用是确定两个元素是否在同一个集合。一般来说，为了能够简化描述集合，Find操作往往是返回一个集合的代表元素，
\item Union：这个是并查集的另一个重要操作。这个操作用以合并不相交的两个集合。Union操作对象则是两个集合的代表元素进行合并。
\end{itemize}

并查集实现方式有多种，上面提到的有基于线性数组，线性链表和，其中并查集森林的实现。这三种实现的复杂度中，线性数组实现的并查集的Find的操作代价
较少是$O(1)$的实现，而Union操作的实现则是$O(n)$,其中$n$是并查集元素的个数。线性链表则正好与其相反，线性链表的Find操作是$O(n)$的实现,而他的
Union操作则是$O(1)$的实现。

介于两者之间的一个结构便是并查集森林的实现，在并查集森零中，各个森林的根节点就是该集合的代表元素。而Find操作则是将在树中向上回溯的寻找根节点
的操作。Union操作则是将两个树的根节点加以合并，让其中的一个集合的根节点作为另一个集合的根节点的父节点。

这样做会带来一个问题，首先由于采用了森林的实现，这样并查集的Union操作仍然是$O(1)$的，但是
当树严重不平衡时，Find操作的过程的代价会变得很大。这样实现的并查集的效率并不高，但是这里可以
采用两种优化的方式进行优化，这两种方式分别是按秩合并和路径压缩策略。

\begin{figure}[htbp]
\centering\includegraphics[width=0.8\textwidth]{Union-crop}
\caption{按秩合并的Union操作}\label{fig:Union}
\end{figure}
按秩合并的主要思想是当两棵大小不同的树进行合并时。为了尽量的不增大树的的深度，往往
会将深度较小的树合并到深度较大的树上去。而在实际的操作中，这个秩一般不是树的深度，
这是因为在进行路径压缩的过程中，树的深度往往会产生变化，因此在实现并查集的过程中，
并查集的秩一般是指该森林的大小，在合并的过程中，将数量较小的森林合并到数量较大的
森林之用进行一次线性的加法操作即可。使用这一种优化的并查集的会使得各个操作的运行时间
提高到Union或Find操作$O(\log n)$。采用按秩合并的Union伪代码如下所示：
\begin{algorithm} 
	\caption {Union-Set Union} 
	\begin{codebox}
		\Procname{$\proc{Union}(u,v)$}
\li			$rootu \leftarrow \proc{Find}(u)$
\li			$rootv \leftarrow \proc{Find}(v)$
\li			\If	$rootu$ $!=$ $rootv$
\li				\Then
					\If $\attribii{rootu}{rank} < \attribii{rootv}{rank}$
\li						\Then
							$\attribii{rootu}{parent} \leftarrow \attribii{rootv}{parent}$
\li							$\attribii{rootv}{rank} \leftarrow \attribii{rootv}{rank} + \attribii{rootu}{rank}$
\li						\Else
\li							$\attribii{rootv}{parent} \leftarrow \attribii{rootu}{parent}$
\li							$\attribii{rootu}{rank} \leftarrow  \attribii{rootv}{rank} + \attribii{rootu}{rank}$
						\End
				\End
\li			\Return	$\attribii{u}{parent}$
	\end{codebox}
\end{algorithm} 

并查集的关键优化方式则是路径压缩优化，在查找的过程中，各个节点均会向上
递归的找寻父节点，而在递归的找寻父节点的同时，可以将当前根节点的父节点
直接标记为整个森林的父节点，这样在进行Find操作的过程中，同时将树的这一
路径扁平化，这样在以后的查找的过程中，可以加速整个Find或是Union的操作
过程
\begin{figure}[htbp]
\centering\includegraphics[width=0.8\textwidth]{Find-crop}
\caption{路径压缩的Find操作}\label{fig:Find}
\end{figure}

路径压缩的主要做法如图所示，结合上述过程，路径压缩的Find伪代码如下所示：
\begin{algorithm} 
	\caption {Union-Set Find} 
	\begin{codebox}
		\Procname{$\proc{Find}(u)$}
\li			\If $\attribii{u}{parent}$ $!=$ $root$
\li			\Then	$\attribii{u}{parent} \leftarrow \proc{Find}(\attribii{u}{parent})$ \End
\li			\Return	$\attribii{u}{parent}$
	\end{codebox}
\end{algorithm} 

这两种技术可以互补，这两个优化可以同时使用，每个操作的平摊时间仅为$O(\alpha(n))$，$\alpha(n)$是$n = f(x) = A(x,x)$的反函数，并且A是急速增加的阿克曼函数。因为$\alpha(n)$是其的反函数，$\alpha(n)$对于可观的巨大$n$还是小于5。因此，对于每个操作而言这是一个极小的常数。

\section{资源分配公平性}
资源分配的公平性，是系统负载均衡的重要指标，无论各种调度算法其本质是使得资源分配的尽量公平，在本节中介绍了公平性
原则的基础原则Max-min算法和评价公平的重要度量方法。为CBDRF调度算法进行调度结果的迭代评估起到了重要的作用。
\subsection{Max-Min分配算法}
Max-Min分配算法是一种典型的公平的资源分配，其主旨是使得各个被分配计算任务的最小值节点资源尽可能大。本质是使得各个计算任务被分配的资源尽量
均衡，不会出现负载不均衡的实现。资源进行映射的过程中，其计算的过程主要由以下的几个步骤组成。
\begin{itemize}
\item	首先，对这个计算的资源按照由大到小的顺序进行排序。
\item	接下来，按照资源的使用量将物理机按照由小到大的顺序进行排序。
\item	对于其中的任务，选择物理机上资源使用量最小的物理机作为调度的结果。
\item	如果此时还有任务剩余，转到步骤一，进行下一个任务的分配。
\item	如果没有带分配的任务，分配结束。
\end{itemize}

Max-Min算法的调度思想在实际的云计算平台调度中有着广泛的应用，在典型按照时间片轮转算法和多队列加权排序，以及Hadoop中的能力调度，公平调度都
是Max-Min算法的一种具体的实现形式，它们可以看作是Max-Min算法在结合实际应用的加强调度算法。实践证明，在云计算平台规模不大，计算任务负载较轻
的情况下，Max-Min算法往往都是比较合理并且性能相对较优的调度算法。
\subsection{公平性的度量}
为评价分配算法的公平性,需要对算法得到的分配结果进行定量的度量\cite{ref34}\cite{ref35},通过度量值判定资源分配算法在该应用背景下的公平性,为资源分配算法的选择提供定量的评估标准。
常见的公平性的度量函数有简氏指数，这是一种对单资源定义公平性的评价，如果分配的向量$X({x}_{1},{x}_{2},...,{x}_{n})$如下所示：
\begin{equation}
Jain(\textbf{X}) = \frac{{(\sum_{i=1}^{n}{x}_{i})}^{2}}{n\sum_{i=1}^{n}{{x}_{i}}^{2}}
\end{equation}
分析公式可以看出，公式的取值时1/n到1的，进一步分析发现
当资源分配最为公平的时候由于各项相等，其简式系数计算的结果为1。
而当资源分配最为不公平的时候，即存在某个独占的情况，其计算结果为1/n。
在此基础之上有一个基于系数$\beta$的单资源统一分配函数，在此基础之上，可以调整$\beta$的取值来采用不同的评价函数进行参数调优。
其公式的定义如下所示：
\begin{equation}
{f}_{\beta} (\textbf{X})= sgn(1-\beta)*{\left[\sum_{i=1}^{n}{\left(\frac{{x}_{i}}{\sum_{j=1}^{n}{x}_{j}} \right)}^{1 - \beta} \right]}^{\frac{1}{\beta}}
\end{equation}

其中$X({x}_{1},{x}_{2},\dot,{x}_{n})$仍为其中的分配结果向量。


\section{本章小结}
 本章详细的介绍了CBDRF算法的基础图论背景和公平性的度量规则，将在下一章中给出基于上述规则的CBDRF调度系统的设计和实现。
%% ----------------------------------------------------------------------
%%% END OF FILE 
%% ----------------------------------------------------------------------
