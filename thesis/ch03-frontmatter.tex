%% ----------------------------------------------------------------------
%% START OF FILE
%% ----------------------------------------------------------------------
%% 
%% Filename: ch03-frontmatter.tex
%% Author: Fred Qi
%% Created: 2012-12-26 09:12:47(+0800)
%% 
%% ----------------------------------------------------------------------
%%% CHANGE LOG
%% ----------------------------------------------------------------------
%% Last-Updated: 2013-03-12 08:16:15(+0800) [by Fred Qi]
%%     Update #: 19
%% ----------------------------------------------------------------------
\chapter{CBDRF算法的相关技术}
\label{chap:outline}
\section{图的联通性算法}
\subsection{强联通分量}
在一个图中，如果其中的边如果是有方向的，则这样的图被称为是一个有向图。而在一个有向图中，存在一对顶点u，v
如果存在从u到v和v到u的两条路径，则这两点是强联通的。进一步的讲，如果图中的任意两个点均是强联通的，这样图
就是一个强联通图。而在非强联图图中，一定存在一个子图，这个字图是一个强联通图，这样子图中的极大强联通字图，
被称为是图中的一个强联通分量。

如图所示，因为顶点1，2，3两两可达，因此图中的节点（1，2，3）构成一个强连通分量。
同理可得，（4，5，6）这三个点也构成了该图的一个强连通分量。
\begin{figure}[htbp]
\centering\includegraphics[scale=0.5]{SCC-crop}
\caption{强联通分量关系图}\label{fig:SCC}
\end{figure}
显然可以采用暴力的算法求解强联通分量，采用双向遍历整个图，然后对每个得到可以的分量取交集可以得到图的所有的强联通分量。
但这种方法的负杂度是$O({N}^{2} + M)$（其中N是图的顶点的个数，M是图中边的个数）。这种算法由于时间复杂度较高，在实际的使用
中往往采用效率较高的Tarjan算法和Kosaraju算法。Tarjan算法和Kosaraju算法这两个算法均是以图的深度优先搜索算法为基础，在深度优先
遍历搜素图的基础上进行了优化，复杂度只有$O(N + M)$。其中Kosaraju算法要对图进行两次深度优先搜索，而
Tarjan算法只进行一遍深度优先搜索索。结合实际的计算，一般来说Tarjan算法比进行两遍深度优先搜索Kosaraju算法有30\%的性能提升。

与其他图论的算法类似，Tarjan算法的输入仍然是一个有向图，其输出为该图的各个联通分量。
在计算开始时，首先定义图中节点的u的深度搜索时间戳DFN（u），表示在搜索过程中第一次访问节点u的顺序编号。
另外，针对每个节点u，还应当计算一个反向时间戳Low（u），这个表示从u出发通过图中的有向边，可以访问的最早的访问顺序。
显然深度搜索的过程中，对于节点u来说，Low（u）的值一定是不大于DFN（u）的，如果这两个值相等，则说明
以节点u为根节点为搜索子树上的其他节点无法到达比u更早的节点，子树中的节点能访问的均在已u为根的搜索子树中。
因此，此时以u为根的搜索子树上的节点必然是在同一强连通分量中。因此可以得到这么一个结论，如果
以u为根的搜索子树上的节点在同一个强联通分量的充分必要条件是Low（u）必须等于DFN（u）。
从Low（u）的定义可以发现，Low（u）的计算情况是以下三种情况的最小值
$$Low(u)=\min
\begin{cases}
DFN(u) & \\
Low(v)& \text{(u,v)为树枝边，u为v的父节点}\\
DFN(v)& \text{(u,v)为指向栈中节点的后向边(非横叉边)}
\end{cases}$$

由此可得，Tarjan算法的基本流程如下：
\begin{enumerate}
\item	首先遍历图中的各个节点，如果该节点已经已经在先前的搜索中被访问，则不对该节点进行深度优先遍历，否则，对该节点进行遍历。
\item	在搜索的过程中首先将节点入栈，对其邻近节点进行进行搜索操作，更新DFN（u）和Low（u）值。
\item	如果出现DFN（u）和Low（u）相同的节点u，那么将包括u以上的节点全部出栈，这些节点属于同一个强联通分量。
\item 	如果此次搜索完成后，节点仍有未被搜索的节点，那么以此节点继续进行搜索。
\end{enumerate}

下面给出了Tarjan算法在搜索过程中执行流程的伪代码：
\begin{algorithm} 
\caption {Tarjan Algorithm} 
\begin{codebox}
\Procname{$\proc{tarjan}(u)$}
\li	$Index \leftarrow time + 1$
\li	$DFN[u] \leftarrow time$
\li	$Low[u] \leftarrow time$
\li	$Stack.push(u)$
\li	\For $each (u, v)$ $in$ $E[u]$
\li		\Do  \If $\proc{visted}(v)$
\li			\Then
				$\proc{tarjan}(v)$                  
\li            			$Low[u] \leftarrow \min(Low[u], Low[v])$
\li        		 \ElseIf $\proc{inStack}(v)$ 
\li            			\Then $Low[u] \leftarrow \min(Low[u], DFN[v])$
			\End
		\End
\li	\If $DFN[u] \isequal Low[u]$
\li		\Then \While $u != v$
\li				\Do $v \leftarrow$ $\proc{Stack.pop}()$                  
\li            				$\proc{print}(v)$
				\End 
		\End
\end{codebox}
\end{algorithm} 

\subsection{拓扑排序}
在图论中，在一个有向图中，不存在任意一个顶点使得从该顶点出发在图中经过若干条边回来出发点的图被称作是有向无环图，简称DAG图。
\begin{figure}[htbp]
\centering\includegraphics[scale=0.5]{DAG-crop}
\caption{DAG图}\label{fig:DAG}
\end{figure}
在一个有向无环图中，一个节点可以经过两条或两条以上的路径而不形成环到达另外一个节点，
因此有向无环图并一定都是树的结构，如上图所示的有向无环图。但是任何一个有向树均可以构成一个有向无环图。

而拓扑排序则是将有向无环图的节点按照在图中出现的节点排序称为一个线性的序列。
这个序列使得图中的任意两个节点u，v，如果u和v之间存在一条从u指向v的有向边，那么拓扑
排序的序列中，u必然排在v之前。这样的一个序列被称作是满足拓扑排序次序的序列，也叫做拓扑序列。
从代数系统的角度上看，拓扑排序则是将一个偏序序列转化称为全序序列的操作的过程。
而这种序列的顺序对于同一个图来说往往不是唯一一个的最小序列。图中就可以有123456和213456这两个不同的拓扑序列。

拓扑排序的过程主要是以下两步，直到图中不存在入度为0的点则算法终止。
\begin{enumerate}
\item 首先，从图中选择一个入度为0的点，将其压入队列中。
\item 从对头选取一个节点，将与从该节点出发的有向边所指向的节点的入度减一。
\item 接下来，从队中弹出该节点，并遍历图中如果有新生成的入度为零的点，则加入队列之中。重复执行步骤2的过程。
\item 循环结束后，如果从队列中弹出的节点个数和图的节点的个数相同，则弹出的顺序就是一个拓扑序列。否则，该图就不是一个有向无环图。
\end{enumerate}

结合上述流程，可以得如下的算法伪代码。
\begin{algorithm} 
\caption {Topological Sort} 
\begin{codebox}
\Procname{$\proc{TopologicalSort}(G)$}
\li Queue.clear()
\li \For $each$ $vertex $ $u$ $in$ $G$
\li	\Do \If $\attribii{u}{indeg}  \isequal 0$
\li		\Then	$Q.push(u)$	
\li				$isVisited[u] \leftarrow True$
		\End
	\End
\li \While $\attribii{Queue}{\proc{size}()} > 0$
\li	\Do	$u \gets \attribii{Queue}{\proc{front}()}$
\li		$\attribii{Queue}{\proc{pop}()}$
\li		\For $each$ $(u,v)$ $in$ $ Edge[v]$
\li			\Do	$ \attribii{v}{indeg} \leftarrow  \attribii{v}{indeg} - 1$
\li			\If $\attribii{v}{indeg}  \isequal $0 and $isVisited[v] \isequal False$
\li				\Then	$Q.push(v)$
\li						$isVisited[v] \leftarrow True$
				\End
	\End
   \End
\end{codebox}
\end{algorithm} 
\subsection{并查集}
在计算机算法中，并查集是用于处理一些不相交集合的合并和查询的数据结构。并查集的实现有多种多样，常见的实现有基于线性数组，线性链表
的实现，还有比较高效的森林结构的实现。但这些实现中有以下2个必须存在的操作：
\begin{itemize}
\item Find：主要是确定该元素所在的集合，这个操作的一个重要的作用是确定两个元素是否在同一个集合。一般来说，为了能够简化描述集合，Find操作往往是返回一个集合的代表元素，
\item Union：这个是并查集的另一个重要操作。这个操作用以合并不相交的两个集合。Union操作对象则是两个集合的代表元素进行合并。
\end{itemize}

并查集实现方式有多种，上面提到的有基于线性数组，线性链表和，其中并查集森林的实现。这三种实现的复杂度中，线性数组实现的并查集的Find的操作代价
较少是$O(1)$的实现，而Union操作的实现则是$O(n)$,其中n是并查集元素的个数。线性链表则正好与其相反，线性链表的Find操作是$O(n)$的实现,而他的
Union操作则是$O(1)$的实现。

介于两者之间的一个结构便是并查集森林的实现，在并查集森零中，各个森林的根节点就是该集合的代表元素。而Find操作则是将在树中向上回溯的寻找根节点
的操作。Union操作则是将两个树的根节点加以合并，让其中的一个集合的根节点作为另一个集合的根节点的父节点。

这样做会带来一个问题，首先由于采用了森林的实现，这样并查集的Union操作仍然是$O(1)$的，但是
当树严重不平衡时，Find操作的过程的代价会变得很大。这样实现的并查集的效率并不高，但是这里可以
采用两种优化的方式进行优化，这两种方式分别是按秩合并和路径压缩策略。

\begin{figure}[htbp]
\centering\includegraphics[scale=0.5]{Union-crop}
\caption{按秩合并的Union操作}\label{fig:Union}
\end{figure}
按秩合并的主要思想是当两棵大小不同的树进行合并时。为了尽量的不增大树的的深度，往往
会将深度较小的树合并到深度较大的树上去。而在实际的操作中，这个秩一般不是树的深度，
这是因为在进行路径压缩的过程中，树的深度往往会产生变化，因此在实现并查集的过程中，
并查集的秩一般是指该森林的大小，在合并的过程中，将数量较小的森林合并到数量较大的
森林之用进行一次线性的加法操作即可。使用这一种优化的并查集的会使得各个操作的运行时间
提高到Union或Find操作O($\log n$)。采用按秩合并的Union伪代码如下所示：
\begin{algorithm} 
	\caption {Union-Set Union} 
	\begin{codebox}
		\Procname{$\proc{Union}(u,v)$}
\li			$rootu \leftarrow \proc{Find}(u)$
\li			$rootv \leftarrow \proc{Find}(v)$
\li			\If	$rootu$ $!=$ $rootv$
\li				\Then
					\If $\attribii{rootu}{rank} < \attribii{rootv}{rank}$
\li						\Then
							$\attribii{rootu}{parent} \leftarrow \attribii{rootv}{parent}$
\li							$\attribii{rootv}{rank} \leftarrow \attribii{rootv}{rank} + \attribii{rootu}{rank}$
\li						\Else
\li							$\attribii{rootv}{parent} \leftarrow \attribii{rootu}{parent}$
\li							$\attribii{rootu}{rank} \leftarrow  \attribii{rootv}{rank} + \attribii{rootu}{rank}$
						\End
				\End
\li			\Return	$\attribii{u}{parent}$
	\end{codebox}
\end{algorithm} 

并查集的关键优化方式则是路径压缩优化，在查找的过程中，各个节点均会向上
递归的找寻父节点，而在递归的找寻父节点的同时，可以将当前根节点的父节点
直接标记为整个森林的父节点，这样在进行Find操作的过程中，同时将树的这一
路径扁平化，这样在以后的查找的过程中，可以加速整个Find或是Union的操作
过程
\begin{figure}[htbp]
\centering\includegraphics[scale=0.5]{Find-crop}
\caption{路径压缩的Find操作}\label{fig:Find}
\end{figure}

路径压缩的主要做法如图所示，结合上述过程，路径压缩的Find伪代码如下所示：
\begin{algorithm} 
	\caption {Union-Set Find} 
	\begin{codebox}
		\Procname{$\proc{Find}(u)$}
\li			\If $\attribii{u}{parent}$ $!=$ $root$
\li			\Then	$\attribii{u}{parent} \leftarrow \proc{Find}(\attribii{u}{parent})$ \End
\li			\Return	$\attribii{u}{parent}$
	\end{codebox}
\end{algorithm} 

这两种技术可以互补，这两个优化可以同时使用，每个操作的平摊时间仅为O($\alpha(n)$)，$\alpha(n)$是n = f(x) = A(x,x)的反函数，并且A是急速增加的阿克曼函数。因为$\alpha$(n)是其的反函数，$\alpha$(n)对于可观的巨大n还是小于5。因此，对于每个操作而言这是一个极小的常数。

\section{资源分配公平性}
\subsection{Max-Min分配算法}
Max-Min分配算法是一种典型的公平的资源分配，其主旨是使得各个被分配计算任务的最小值节点资源尽可能大。本质是使得各个计算任务被分配的资源尽量
均衡，不会出现负载不均衡的实现。资源进行映射的过程中，其计算的过程主要由以下的几个步骤组成。
\begin{itemize}
\item	首先，对这个计算的资源按照由大到小的顺序进行排序。
\item	接下来，按照资源的使用量将物理机按照由小到大的顺序进行排序。
\item	对于其中的任务，选择物理机上资源使用量最小的物理机作为调度的结果。
\item	如果此时还有任务剩余，转到步骤一，进行下一个任务的分配。
\item	如果没有带分配的任务，分配结束。
\end{itemize}

Max-Min算法的调度思想在实际的云计算平台调度中有着广泛的应用，在典型按照时间片轮转算法和多队列加权排序，以及Hadoop中的能力调度，公平调度都
是Max-Min算法的一种具体的实现形式，它们可以看作是Max-Min算法在结合实际应用的加强调度算法。实践证明，在云计算平台规模不大，计算任务负载较轻
的情况下，Max-Min算法往往都是比较合理并且性能相对较优的调度算法。
\subsection{公平性的度量}
为评价分配算法的公平性,需要对算法得到的分配结果进行定量的度量,通过度量值判定资源分配算法在该应用背景下的公平性,为资源分配算法的选择提供定量的评估标准。
常见的公平性的度量函数有简氏指数，这是一种对单资源定义公平性的评价，如果分配的向量$X({x}_{1},{x}_{2},...,{x}_{n})$如下所示：
\begin{equation}
Jain(\textbf{X}) = \frac{{(\sum_{i=1}^{n}{x}_{i})}^{2}}{n\sum_{i=1}^{n}{{x}_{i}}^{2}}
\end{equation}
分析公式可以看出，公式的取值时1/n到1的，进一步分析发现
当资源分配最为公平的时候由于各项相等，其简式系数计算的结果为1。
而当资源分配最为不公平的时候，即存在某个独占的情况，其计算结果为1/n。
在此基础之上有一个基于系数$\beta$的单资源统一分配函数，在此基础之上，可以调整$\beta$的取值来采用不同的评价函数进行参数调优。
其公式的定义如下所示：
\begin{equation}
{f}_{\beta} (\textbf{X})= sgn(1-\beta)*{\left[\sum_{i=1}^{n}{\left(\frac{{x}_{i}}{\sum_{j=1}^{n}{x}_{j}} \right)}^{1 - \beta} \right]}^{\frac{1}{\beta}}
\end{equation}

其中$X({x}_{1},{x}_{2},\dot,{x}_{n})$仍为其中的分配结果向量。


\section{本章小结}
 本章详细的介绍了CBDRF算法的基础图论背景和公平性的度量规则，将在下一章中给出j基于上述规则的CBDRF调度系统的设计和实现。
%% ----------------------------------------------------------------------
%%% END OF FILE 
%% ----------------------------------------------------------------------
